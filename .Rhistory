names(d_tsne) <- c("tsne1","tsne2")
d_tsne$label <- x$label
ggplot(data = d_tsne, aes(x = tsne1, y = tsne2, col = label)) +
geom_point() +
ggtitle("2D t-SNE visualization")
#And now with umap:
library(uwot)
umap_coords = umap(x.num,
n_neighbors = 15,
min_dist = 0.001,
verbose = TRUE)
str(umap_coords)
umap_coords = as.data.frame(umap_coords)
umap_coords$label = x$label
ggplot(data = umap_coords, aes(x=V1, y=V2, color=label) ) +
geom_point() +
xlab("UMAP 1") + ylab("UMAP 2") +
ggtitle("2D UMAP visualization")
dat <- read.table("http://stat.ethz.ch/Teaching/Datasets/WBL/dat_3D_2.dat", header = TRUE)
library(GGally)
ggpairs(dat)
library(mvoutlier)
res <- mvoutlier::chisq.plot(dat)
Z = prcomp(dat, scale. = TRUE)
plot(Z$x[,1], Z$x[,2])
Z = prcomp(dat, scale. = TRUE)
plot(Z$x[,1], Z$x[,2])
library(rrcov)
Z.robust <- PcaHubert(dat, scale=T)
plot(Z.robust)
churn <- read.csv2("C:\\Users\\LMF\\polybox\\CAS\\Multivariate Statistik I\\Datasets\\churn.csv",
stringsAsFactors = TRUE)
str(churn)
churn <- read.csv2("C:\\Users\\LMF\\polybox\\Courses_Taken\\CAS\\Multivariate Statistik I\\Datasets\\churn.csv",
stringsAsFactors = TRUE)
str(churn)
library(cluster)
dissMat <- cluster::daisy(churn)
mdist=as.matrix(dissMat)
library(pheatmap)
pheatmap::pheatmap(mdist)
library(cluster)
dissMat <- cluster::daisy(churn)
mdist=as.matrix(dissMat)
library(pheatmap)
pheatmap::pheatmap(mdist)
library(MASS)
dim2 <- MASS::isoMDS(mdist, k=2)
d.mds = as.data.frame(dim2$points)
names(d.mds)=c("c1", "c2")
library(ggplot2)
ggplot(data=d.mds, aes(x=c1, y=c2)) +
geom_point(col=as.numeric(churn$Churn)) +
geom_text(label=row.names(mdist),hjust=1.2)
abst <- read.table("C:/Users/mlucas/polybox/Courses_Taken/CAS/Multivariate Statistik I/Datasets/abst.txt"
, header = T, sep="\t")
abst <- read.table("C:/Users/mlucas/polybox/Courses_Taken/CAS/Multivariate Statistik I/Datasets/abst.txt"
, header = T, sep="\t")
abst <- read.table("C:/Users/LMF/polybox/Courses_Taken/CAS/Multivariate Statistik I/Datasets/abst.txt"
, header = T, sep="\t")
library(tidyr)
abst_long = gather(data=abst,
key=poll_id,
value=yes_prop,
can439:can458,
factor_key=TRUE)
View(abst_long)
View(abst)
View(abst_long)
X=as.matrix(abst[,-1])
row.names(X)=abst$Kanton
pheatmap(X, clustering_method="ward.D2")
library(ggplot2)
ggplot(data=abst_long, mapping=aes(x=Kanton,y=yes_prop)) + geom_boxplot()+
geom_abline(slope = 0, intercept=0.5, color="red")
row.names(X)=abst$Kanton
pheatmap(X, clustering_method="ward.D2")
#PCA ANALYSIS:
Z = prcomp(X, scale. = TRUE)
plot(Z$x[,1], Z$x[,2], main="after scaling")
text(Z$x[,1], Z$x[,2], labels = abst$Kanton, pos=1)
Z = prcomp(X, scale. = FALSE)$x
plot(Z[,1], Z[,2], col='red', main="without scaling")
text(Z[,1], Z[,2], labels = abst$Kanton, pos=1)
library(ggfortify)
Z = prcomp(X, scale. = TRUE)
autoplot(Z) +
geom_text(label=abst$Kanton, size=2.5, hjust=1.1) +
geom_hline(yintercept = 0, col="red") +
geom_vline(xintercept=0, col="red")
abst.pcS = prcomp(X, scale. = TRUE)
summary(abst.pcS)
#Exercise 2
dat <- scale(as.matrix(USArrests[,c(1,2,4)]), center = TRUE, scale = FALSE)
stars(dat, draw.segments = T)
pcRes <- prcomp(dat, scale. = TRUE)
idx <- pcRes$x[,1]
y <- sort(idx)
plot(1:50, y, type = "n", )
text(1:50, y, labels = rownames(dat)[order(idx)], cex = 0.7)
pcRes <- prcomp(dat, scale. = TRUE)
idx <- pcRes$x[,1]
y <- sort(idx)
plot(1:50, y, type = "n", )
text(1:50, y, labels = rownames(dat)[order(idx)], cex = 0.7)
library(ggfortify)
pcRes <- prcomp(dat, scale. = TRUE)
autoplot(pcRes) +
geom_text(label=row.names(dat), size=2.5, hjust=1.1)
y
library(MASS)
data("Pima.tr")
data("Pima.te")
tr <- data("Pima.tr")
tr <- Pima.tr
te <- Pima.te
library(dplyr)
count(tr, type)
count(te,type)
set.seed(1)
#2
set.seed(1)
resTSNE <- Rtsne(tr, perplexity = 10)
d_tsne <- as.data.frame(resTSNE$Y)
names(d_tsne) <- c("tsne1","tsne2")
d_tsne$label <- x$label
d_tsne$label <- tr$type
ggplot(data = d_tsne, aes(x = tsne1, y = tsne2, col = label)) +
geom_point() +
ggtitle("2D t-SNE visualization")
set.seed(1)
resTSNE <- Rtsne(tr, perplexity = 10)
d_tsne <- as.data.frame(resTSNE$Y)
names(d_tsne) <- c("tsne1","tsne2")
d_tsne$label <- tr$type
ggplot(data = d_tsne, aes(x = tsne1, y = tsne2, col = label)) +
geom_point() +
ggtitle("2D t-SNE visualization")
#c)
library(randomForest)
set.seed(1)
rf <- randomForest(type ~., data=tr)
print(rf)
forecast <- predict(rf, te)
te <- cbind(te, forecast)
View(te)
te$error <- ifelse(te$type != te$forecast, 1,0)
count(te, error)
79/nrow(te)
count(te, error==1 & type=="Yes")
varImpPlot(rf)
rf <- randomForest(type ~., data=tr, importance=T)
varImpPlot(rf)
partialPlot(rf, te, x.var = "glu")
partialPlot(rf, tr, x.var = "glu")
partialPlot(rf, te, x.var = "glu")
#Exercise 6
library(MASS)
library(rpart)
library(party)
library(partykit)
data("crabs", package = "MASS")
crabs <- crabs
str(crabs)
crabsPred <- crabs[, c("sp", "sex", "FL", "RW", "CL", "CW", "BD")]
model <- rpart(sex ~ ., data=crabsPred)
pred = predict(model, type="class")
plot(model)
partyModel <- as.party.rpart(model)
plot(partyModel)
crabsPred$pred_sex <-predict(model, type="class")
table(crabsPred$pred_sex, crabsPred$sex)
accuracy <- (90+95)/sum(table(crabsPred$pred_sex, crabsPred$sex))
#b)
library(ggplot2)
ggplot(data=crabsPred, aes(x=RW, y=CL, col=sex, shape=pred_sex)) +
geom_point() +
geom_vline(xintercept=15.9)
#d)
str(crabs)
pca = prcomp(crabs[,4:8], scale. = FALSE)
summary(pca)
dat_pca = data.frame(pc1=pca$x[,1], pc2=pca$x[,2],
pc3=pca$x[,3], pc4=pca$x[,4], pc5=pca$x[,5])
dat_pca$sex=crabs$sex
dat_pca$pred_sex=crabsPred$pred_sex
ggplot(dat_pca , aes(x=pc1, y=pc2, col=sex, shape=pred_sex)) +
geom_point() +
xlab("PC1 (98%)") +
ylab("PC2 (1%)")
#e) PCA HinzufÃ¼gen
crabs2 <- cbind(crabs, pca$x)
str(crabs2)
crabsPred2 <- crabs2[, c("sp", "sex", "FL", "RW", "CL", "CW", "BD", "PC1", "PC2", "PC3", "PC4")]
model <- rpart(sex ~ ., data=crabsPred2)
partyModel <- as.party.rpart(model)
plot(partyModel)
crabsPred2$pred_sex <-predict(model, type="class")
table(crabsPred$pred_sex, crabsPred$sex)
crabsPred2$pred_sex_pca = crabsPred2$pred_sex_pca
ggplot(crabsPred2 , aes(x=PC2, y=PC3, col=sex, shape=pred_sex)) +
geom_point() +
geom_vline(xintercept=0.02)
#Exercise 7____________________________________________________________________________________________
library(MASS)
library(dplyr)
library(tidymodels)
library(randomForest)
boston <- Boston
split <- initial_split(boston, prop=0.7)
train <- training(split)
test <- testing(split)
lm.m <- lm(medv ~., data=train)
rf.m <- randomForest(medv ~., data=train, importance=T)
test$pred.lm <- predict(lm.m, test)
test$pred.rf <- predict(rf.m, test)
ggplot(data=test, aes(x=pred.lm, y=medv))+geom_point()+geom_abline(intercept = 0, slope=1)
ggplot(data=test, aes(x=pred.rf, y=medv))+geom_point()+geom_abline(intercept = 0, slope=1)
#MSE:
mse.lm <- mean((test$pred.lm - test$medv)^2)
mse.rf <- mean((test$pred.rf - test$medv)^2)
mse.lm
mse.rf
summary(lm.m)
varImpPlot(rf.m)
partialPlot(rf.m, Boston, x.var = "rm")
partialPlot(rf.m, Boston, x.var = "lstat")
function (n, df1, df2, ncp)
{
if (missing(ncp))
.Call(C_rf, n, df1, df2)
else (rchisq(n, df1, ncp = ncp)/df1)/(rchisq(n, df2)/df2)
}
varImpPlot(rf)
partialPlot(rf, te, x.var = "glu")
library(mlr)
install.packages("mlr")
partialPlot(rf, te, x.var = "glu")
str(te)
View(te)
#Exercise 3
setwd("C:/Users/LMF/polybox/Courses_Taken/CAS/Multivariate Statistik I/Datasets")
load("wine_num.Rdata")
#Exercise 3
load(url("http://stat.ethz.ch/Teaching/Datasets/WBL/wine_num.RData"))
wine.df <- as.data.frame(wine)
View(wine.df)
library(ggplot2)
boxplot(wine.df)
#Skalieren:
wineScaled <- scale(wine.df)
boxplot(wineScaled)
dist <- dist(wineScaled)
mdist=as.matrix(dist)
cluster <- hclust(mdist, method = "complete")
cluster <- hclust(dist, method = "complete")
plot(cluster)
dist <- dist(wineScaled, method="euclidean")
cluster <- hclust(dist, method = "complete")
plot(cluster)
groups <- cutree(cluster, k=4)
plot(groups)
silhouette(groups)
silhouette(dist, groups)
silhouette(mdist, groups)
cluster
cluster$merge
cluster$labels
cluster$height
cluster$merge
groups
silhouette(groups, dist)
plot(silhouette(groups, dist))
set.seed(1)
plot(silhouette(groups, dist))
plot(silhouette(groups, dist), col=1:4)
plot(silhouette(groups, dist, col=1:4))
plot(silhouette(groups, dist), col=1:4)
plot(silhouette(groups, dist), col=c("red"))
plot(silhouette(groups, dist), col=c("red"))
plot(silhouette(groups, dist), col=c("red", "blue"))
plot(silhouette(groups, dist), col=1:4)
pheatmap::pheatmap(mdist)
pheatmap::pheatmap(mdist, clustering_method = "complete")
pheatmap::pheatmap(mdist, clustering_method = "ward.D2")
pheatmap::pheatmap(mdist, clustering_method = "complete")
pheatmap::pheatmap(mdist, clustering_method = "complete", legend = T)
pheatmap::pheatmap(mdist, clustering_method = "complete", show_rownames = T)
pheatmap::pheatmap(mdist, clustering_method = "complete", annotation_col = wine.df$Proline)
pheatmap::pheatmap(mdist, clustering_method = "complete", annotation_col = as.data.frame(wine.df$Proline))
Z = prcomp(wineScaled)
plot(Z$x[,1], Z$x[,2], main="after scaling")
autoplot(Z) +
geom_text(label=abst$Kanton, size=2.5, hjust=1.1) +
geom_hline(yintercept = 0, col="red") +
geom_vline(xintercept=0, col="red")
autoplot(Z) +
geom_hline(yintercept = 0, col="red") +
geom_vline(xintercept=0, col="red")
plot(Z$x[,1], Z$x[,2], main="after scaling")
autoplot(Z) +
geom_text(label=w, size=2.5, hjust=1.1) +
geom_hline(yintercept = 0, col="red") +
geom_vline(xintercept=0, col="red")
autoplot(Z) +
geom_hline(yintercept = 0, col="red") +
geom_vline(xintercept=0, col="red")
plot(Z$x[,1], Z$x[,2], main="after scaling", col=groups)
plot(Z$x[,1], Z$x[,2], main="after scaling", col=groups, label=groups)
devtools::document()
devtools::document()
usethis::use_package("parallel")
devtools::document()
devtools::document()
devtools::build()
devtools::install_github("mflucas/brouterR")
rm(list = ls())
synthPop <- readRDS("C:\\Users\\LMF\\polybox\\BetwAcc_EBikeCity\\DATA\\synthPop_ZH_FINAL_withW.rds")
trips <- read.csv2("C:\\Users\\LMF\\polybox\\BetwAcc_EBikeCity\\DATA\\MATSim Output\\40.trips.csv")
trips <- trips[trips$person %in% synthPop$person, ]
potBike <- trips[trips$traveled_distance>100 & trips$traveled_distance<40000, ]
#Now convert coordinates to WGS84
library(sp)
potBike$start_y <- as.numeric(potBike$start_y)
potBike$start_x <- as.numeric(potBike$start_x)
coordinates(potBike) <- ~ start_x + start_y
potBike@proj4string <- CRS("+init=epsg:2056")
potBike <- spTransform(potBike, CRS("+init=epsg:4326"))
potBike$startLat <- potBike@coords[,2]
potBike$startLon <- potBike@coords[,1]
potBike$end_y <- as.numeric(potBike$end_y)
potBike$end_x <- as.numeric(potBike$end_x)
potBike <- potBike@data
coordinates(potBike) <- ~ end_x + end_y
potBike@proj4string <- CRS("+init=epsg:2056")
potBike <- spTransform(potBike, CRS("+init=epsg:4326"))
potBike$endLat <- potBike@coords[,2]
potBike$endLon <- potBike@coords[,1]
potBike <- potBike@data
potBike$id <- c(1:nrow(potBike))
#Now add optional data:
library(dplyr)
potBike$bikerPower <- synthPop$W[match(unlist(potBike$person), synthPop$person)]
potBike$totalMass <- synthPop$Weight[match(unlist(potBike$person), synthPop$person)]
#add Bike + material weight
potBike$totalMass <- potBike$totalMass+15
#add resistance factors from Tengatti & Bengazzi2018:
potBike$dragCoefficient <- 0.559
potBike$rollingResistance <- 0.0077
potBike$maxSpeed <- 34
#Before start remove those with too little power:
potBikeFinal <- potBike[potBike$bikerPower>30, ]
shareUnder30 <-(nrow(potBike)-nrow(potBikeFinal))/nrow(potBikeFinal)
potBikeFinal <- potBikeFinal[!(potBikeFinal$start_activity_type=="outside" | potBikeFinal$end_activity_type=="outside"),]
#Now perform the routing:
library(brouterR)
pathBrouter <- "C:\\Users\\LMF\\polybox\\BetwAcc_EBikeCity\\brouter-1.6.3\\brouter-1.6.3"
#
# start_time <- Sys.time()
# test <- calculateAggrMetrics(potBikeFinal[1:1000, ], pathToBRouter = pathBrouter)
# end_time <- Sys.time()
# end_time - start_time
set.seed(4894)
synthPopSample <- synthPop
potBikeSample <- potBikeFinal[potBikeFinal$person %in% synthPopSample$person, ]
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
outputFormat = "gpx"
)
devtools::load_all()
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
outputFormat = "gpx",
pathToBRouter = pathBrouter
)
View(test)
source("~/GitHub/brouterR/R/calculateRoute.R")
devtools::load_all()
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
outputFormat = "gpx"  )
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
# endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
outputFormat = "gpx"  )
Q
#' @param dragCoefficient The wind drag coefficient in m2. Defaults to 0.559
#' @param rollingResistance The rolling resistance of the underground. Default value assumes dry asphalt, 0.0077
#' @param maxSpeed The maximum speed achieved by the bike in km/h. Defaults to 45 km/h.
#'
#' @return
#' @export
#'
#' @examples
#'
#'
library(tmaptools)
devtools::load_all()
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
outputFormat = "gpx"  )
View(test)
plot(test)
#' @param dragCoefficient The wind drag coefficient in m2. Defaults to 0.559
#' @param rollingResistance The rolling resistance of the underground. Default value assumes dry asphalt, 0.0077
#' @param maxSpeed The maximum speed achieved by the bike in km/h. Defaults to 45 km/h.
#'
#' @return
#' @export
#'
#' @examples
#'
#'
library(plotKML)
devtools::load_all()
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
outputFormat = "gpx"  )
View(test)
plot(test)
plot(test[[1]])
plot(test$tracks[1])
plot(test$tracks[[1]])
plot(test$tracks)
plot(test$waypoints)
plot(test$routes)
typeof(test)
View(synthPopSample)
View(test)
track <- test$tracks[[1]]
View(track)
track <- test$tracks[[1]]$brouter_trekking_0
plot(track)
View(track)
coordinates(track) <- ~ lat + lon
track@proj4string <- CRS("+init=epsg:2056")
plot(track)
View(track)
track <- test$tracks[[1]]$brouter_trekking_0
coordinates(track) <- ~ lat + lon
View(track)
track <- test$tracks[[1]]$brouter_trekking_0
coordinates(track) <- ~ lat + lon
track@proj4string <- CRS("+init=epsg:2056")
View(track)
usethis::use_package("plotKML")
usethis::use_package("sp")
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
profile="fastbike-lowtraffic",
outputFormat = "gpx"  )
track <- test$tracks[[1]]$brouter_trekking_0
View(test)
track <- test$tracks[[1]]
View(track)
track <- track[1]
track <- track[[1]]
track <- test$tracks[[1]][[1]]
coordinates(track) <- ~ lat + lon
track@proj4string <- CRS("+init=epsg:2056")
View(track)
devtools::load_all()
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
profile="fastbike-lowtraffic",
outputFormat = "gpx"  )
View(test)
devtools::load_all()
test <- calculateRoute(startLat = potBikeSample[1,]$startLat,
startLon = potBikeSample[1,]$startLon,
endLat   = potBikeSample[1,]$endLat,
endLon = potBikeSample[1,]$endLon,
profile="fastbike-lowtraffic",
outputFormat = "gpx"  )
View(test)
devtools::document()
libPaths()
.libPaths()
paths <- .libPaths()
for(i in 1:length(paths)){
i
}
for(i in 1:length(paths)){
print(i)
}
path <- paths[i]
list.files(path)
i=1
path <- paths[i]
list.files(path)
any(list.files(path)=="jsonify")
any(list.files(path)=="brouterR")
install_github("https://github.com/mflucas/brouterR")
require(devtools)
install_github("https://github.com/mflucas/brouterR")
install_github("https://github.com/mflucas/brouterR")
install_github("https://github.com/mflucas/brouterR")
