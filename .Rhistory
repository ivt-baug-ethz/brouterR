iter <- brouterR::splitForCores(df=df, nrOfNodes=nrOfNodes)
resultList <- parallel::clusterApply(cl, iter, function(matrix){
output <-  vector(mode='list', length=nrow(matrix))
for(i in 1:nrow(matrix)){
line <- matrix[i, ]
id=line[2]
thisRoute <- tryCatch(
{
route <- brouterR::calculateRoute(startLat=line[3],
startLon=line[4],
endLat=line[5],
endLon=line[6],
bikerPower=line[7],
totalMass=line[8],
dragCoefficient=line[9],
rollingResistance=line[10],
maxSpeed=line[11],
serverNodeId = line[1],
outputFormat = "df",
profile=profile)
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
distance <- sum(route$Distance)
energy <- max(route$Energy)
#Calculate average slope:
dElev <- diff(route$Elevation)
route <- route[-1,]
route$dElev <- dElev
route$slope <- 100*route$dElev/route$Distance
avgSlopeUp <- mean(route[route$slope>0,]$slope)
avgSlopeDown <- mean(route[route$slope<0,]$slope)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
},
error=function(e){
thisRoute <- c(id=id,
travelTime=-99,
distance=-99,
energy=-99,
avgSlopeUp=-99,
avgSlopeDown=-99
)
}
)
output[[i]] <-thisRoute
}
return(output)
})
parallel::stopCluster(cl)
View(resultList)
View(output)
route <- brouterR::calculateRoute(startLat=line[3],
startLon=line[4],
endLat=line[5],
endLon=line[6],
bikerPower=line[7],
totalMass=line[8],
dragCoefficient=line[9],
rollingResistance=line[10],
maxSpeed=line[11],
serverNodeId = line[1],
outputFormat = "df",
profile=profile)
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+
sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
distance <- sum(route$Distance)
energy <- max(route$Energy)
#Calculate average slope:
dElev <- diff(route$Elevation)
route <- route[-1,]
route$dElev <- dElev
route$slope <- 100*route$dElev/route$Distance
avgSlopeUp <- mean(route[route$slope>0,]$slope)
avgSlopeDown <- mean(route[route$slope<0,]$slope)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
thisRoute <- tryCatch(
{
route <- brouterR::calculateRoute(startLat=line[3],
startLon=line[4],
endLat=line[5],
endLon=line[6],
bikerPower=line[7],
totalMass=line[8],
dragCoefficient=line[9],
rollingResistance=line[10],
maxSpeed=line[11],
serverNodeId = line[1],
outputFormat = "df",
profile=profile)
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
distance <- sum(route$Distance)
energy <- max(route$Energy)
#Calculate average slope:
dElev <- diff(route$Elevation)
route <- route[-1,]
route$dElev <- dElev
route$slope <- 100*route$dElev/route$Distance
avgSlopeUp <- mean(route[route$slope>0,]$slope)
avgSlopeDown <- mean(route[route$slope<0,]$slope)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
},
error=function(e){
thisRoute <- c(id=id,
travelTime=-99,
distance=-99,
energy=-99,
avgSlopeUp=-99,
avgSlopeDown=-99
)
}
)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
View(iter)
iter[[1]]
brouterR::setServers(pathToBRouter = pathToBrouter, nrOfNodes =nrOfNodes)
brouterR::startServers(pathToBRouter = pathToBrouter, noServers=nrOfNodes)
#Prepare data and make checks
if(is.data.frame(df)==FALSE){
df <- data.frame(df)
}
if(!all((c("startLat", "startLon", "endLat", "endLon", "id")) %in% colnames(df))){
stop("Coordinates columns missing or wrongly named.
The following columns are obligatory: 'id','startLat', 'startLon', 'endLat', 'endLon'.")
}
optional <- optional
colnames <- colnames(df)
this <- optional %in% colnames
use <- optional[this]
serverNode <- rep(1:nrOfNodes,each=ceiling(nrow(df)/nrOfNodes))
df$serverNode <- serverNode[1:nrow(df)]
col_order <- c("serverNode", "id", "startLat",
"startLon", "endLat", "endLon")
allCols <- c(col_order, use)
bikerPower <- 100
totalMass <- 90
dragCoefficient <- 0.559
rollingResistance <- 0.0077
maxSpeed <- 45
if(!("bikerPower" %in% use)){
df$bikerPower <- bikerPower
}
if(!("totalMass" %in% use)){
df$totalMass <- totalMass
}
if(!("dragCoefficient" %in% use)){
df$dragCoefficient <- dragCoefficient
}
if(!("rollingResistance" %in% use)){
df$rollingResistance <- rollingResistance
}
if(!("maxSpeed" %in% use)){
df$maxSpeed <- maxSpeed
}
allCols <- c("serverNode", "id","startLat",
"startLon", "endLat", "endLon", "bikerPower", "totalMass", "dragCoefficient", "rollingResistance", "maxSpeed")
df <- df[,allCols]
cl = parallel::makeCluster(nrOfNodes)
parallel::clusterExport(cl = cl,
unclass(lsf.str(envir = asNamespace("brouterR"),
all = T))
)
parallel::clusterExport(cl, c("profile", "pathToBrouter"))
iter <- brouterR::splitForCores(df=df, nrOfNodes=nrOfNodes)
resultList <- parallel::clusterApply(cl, iter, function(matrix){
output <-  vector(mode='list', length=nrow(matrix))
for(i in 1:nrow(matrix)){
line <- matrix[i, ]
id=line[2]
thisRoute <- tryCatch(
{
route <- brouterR::calculateRoute(startLat=line[3],
startLon=line[4],
endLat=line[5],
endLon=line[6],
bikerPower=line[7],
totalMass=line[8],
dragCoefficient=line[9],
rollingResistance=line[10],
maxSpeed=line[11],
serverNodeId = line[1],
outputFormat = "df",
profile=profile)
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
distance <- sum(route$Distance)
energy <- max(route$Energy)
#Calculate average slope:
dElev <- diff(route$Elevation)
route <- route[-1,]
route$dElev <- dElev
route$slope <- 100*route$dElev/route$Distance
avgSlopeUp <- mean(route[route$slope>0,]$slope)
avgSlopeDown <- mean(route[route$slope<0,]$slope)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
},
error=function(e){
thisRoute <- c(id=id,
travelTime=-99,
distance=-99,
energy=-99,
avgSlopeUp=-99,
avgSlopeDown=-99
)
}
)
output[[i]] <-thisRoute
}
return(output)
})
parallel::stopCluster(cl)
View(resultList)
unclass(lsf.str(envir = asNamespace("brouterR")
unclass(lsf.str(envir = asNamespace("brouterR"),
all = T)
unclass(lsf.str(envir = asNamespace("brouterR"),
all = T))
cl = parallel::makeCluster(nrOfNodes)
parallel::clusterExport(cl = cl,
unclass(lsf.str(envir = asNamespace("brouterR"),
all = T))
)
parallel::clusterExport(cl, c("profile", "pathToBrouter", "iter"))
cl = parallel::makeCluster(nrOfNodes)
parallel::clusterExport(cl = cl,
unclass(lsf.str(envir = asNamespace("brouterR"),
all = T))
)
iter <- brouterR::splitForCores(df=df, nrOfNodes=nrOfNodes)
parallel::clusterExport(cl, c("profile", "pathToBrouter", "iter"))
resultList <- parallel::clusterApply(cl, iter, function(matrix){
output <-  vector(mode='list', length=nrow(matrix))
for(i in 1:nrow(matrix)){
line <- matrix[i, ]
id=line[2]
thisRoute <- tryCatch(
{
route <- brouterR::calculateRoute(startLat=line[3],
startLon=line[4],
endLat=line[5],
endLon=line[6],
bikerPower=line[7],
totalMass=line[8],
dragCoefficient=line[9],
rollingResistance=line[10],
maxSpeed=line[11],
serverNodeId = line[1],
outputFormat = "df",
profile=profile)
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
distance <- sum(route$Distance)
energy <- max(route$Energy)
#Calculate average slope:
dElev <- diff(route$Elevation)
route <- route[-1,]
route$dElev <- dElev
route$slope <- 100*route$dElev/route$Distance
avgSlopeUp <- mean(route[route$slope>0,]$slope)
avgSlopeDown <- mean(route[route$slope<0,]$slope)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
},
error=function(e){
thisRoute <- c(id=id,
travelTime=-99,
distance=-99,
energy=-99,
avgSlopeUp=-99,
avgSlopeDown=-99
)
}
)
output[[i]] <-thisRoute
}
return(output)
})
View(resultList)
library(RCurl)
cl = parallel::makeCluster(nrOfNodes)
parallel::clusterExport(cl = cl,
unclass(lsf.str(envir = asNamespace("brouterR"),
all = T))
)
iter <- brouterR::splitForCores(df=df, nrOfNodes=nrOfNodes)
parallel::clusterExport(cl, c("profile", "pathToBrouter"))
resultList <- parallel::clusterApply(cl, iter, function(matrix){
output <-  vector(mode='list', length=nrow(matrix))
for(i in 1:nrow(matrix)){
line <- matrix[i, ]
id=line[2]
thisRoute <- tryCatch(
{
route <- brouterR::calculateRoute(startLat=line[3],
startLon=line[4],
endLat=line[5],
endLon=line[6],
bikerPower=line[7],
totalMass=line[8],
dragCoefficient=line[9],
rollingResistance=line[10],
maxSpeed=line[11],
serverNodeId = line[1],
outputFormat = "df",
profile=profile)
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
distance <- sum(route$Distance)
energy <- max(route$Energy)
#Calculate average slope:
dElev <- diff(route$Elevation)
route <- route[-1,]
route$dElev <- dElev
route$slope <- 100*route$dElev/route$Distance
avgSlopeUp <- mean(route[route$slope>0,]$slope)
avgSlopeDown <- mean(route[route$slope<0,]$slope)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
},
error=function(e){
thisRoute <- c(id=id,
travelTime=-99,
distance=-99,
energy=-99,
avgSlopeUp=-99,
avgSlopeDown=-99
)
}
)
output[[i]] <-thisRoute
}
return(output)
})
View(resultList)
library(doSNOW)
cl = parallel::makeCluster(nrOfNodes)
parallel::clusterExport(cl = cl,
unclass(lsf.str(envir = asNamespace("brouterR"),
all = T))
)
iter <- brouterR::splitForCores(df=df, nrOfNodes=nrOfNodes)
parallel::clusterExport(cl, c("profile", "pathToBrouter"))
resultList <- parallel::clusterApply(cl, iter, function(matrix){
output <-  vector(mode='list', length=nrow(matrix))
for(i in 1:nrow(matrix)){
line <- matrix[i, ]
id=line[2]
thisRoute <- tryCatch(
{
route <- brouterR::calculateRoute(startLat=line[3],
startLon=line[4],
endLat=line[5],
endLon=line[6],
bikerPower=line[7],
totalMass=line[8],
dragCoefficient=line[9],
rollingResistance=line[10],
maxSpeed=line[11],
serverNodeId = line[1],
outputFormat = "df",
profile=profile)
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
distance <- sum(route$Distance)
energy <- max(route$Energy)
#Calculate average slope:
dElev <- diff(route$Elevation)
route <- route[-1,]
route$dElev <- dElev
route$slope <- 100*route$dElev/route$Distance
avgSlopeUp <- mean(route[route$slope>0,]$slope)
avgSlopeDown <- mean(route[route$slope<0,]$slope)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
},
error=function(e){
thisRoute <- c(id=id,
travelTime=-99,
distance=-99,
energy=-99,
avgSlopeUp=-99,
avgSlopeDown=-99
)
}
)
output[[i]] <-thisRoute
}
return(output)
})
parallel::stopCluster(cl)
View(resultList)
library(doParallel)
cl = parallel::makeCluster(nrOfNodes)
parallel::clusterExport(cl = cl,
unclass(lsf.str(envir = asNamespace("brouterR"),
all = T))
)
iter <- brouterR::splitForCores(df=df, nrOfNodes=nrOfNodes)
parallel::clusterExport(cl, c("profile", "pathToBrouter"))
resultList <- parallel::clusterApply(cl, iter, function(matrix){
output <-  vector(mode='list', length=nrow(matrix))
for(i in 1:nrow(matrix)){
line <- matrix[i, ]
id=line[2]
thisRoute <- tryCatch(
{
route <- brouterR::calculateRoute(startLat=line[3],
startLon=line[4],
endLat=line[5],
endLon=line[6],
bikerPower=line[7],
totalMass=line[8],
dragCoefficient=line[9],
rollingResistance=line[10],
maxSpeed=line[11],
serverNodeId = line[1],
outputFormat = "df",
profile=profile)
travelTime <- max(route$Time)
#Add penalty of 10secs for each traffic light intersection crossed:
travelTime <- travelTime+sum(grepl("traffic_sign", route$NodeTags)==TRUE)*10
distance <- sum(route$Distance)
energy <- max(route$Energy)
#Calculate average slope:
dElev <- diff(route$Elevation)
route <- route[-1,]
route$dElev <- dElev
route$slope <- 100*route$dElev/route$Distance
avgSlopeUp <- mean(route[route$slope>0,]$slope)
avgSlopeDown <- mean(route[route$slope<0,]$slope)
thisRoute <- c(id=id,
travelTime=as.numeric(travelTime),
distance=as.numeric(distance),
energy=as.numeric(energy),
avgSlopeUp=as.numeric(avgSlopeUp),
avgSlopeDown=as.numeric(avgSlopeDown)
)
},
error=function(e){
thisRoute <- c(id=id,
travelTime=-99,
distance=-99,
energy=-99,
avgSlopeUp=-99,
avgSlopeDown=-99
)
}
)
output[[i]] <-thisRoute
}
return(output)
})
parallel::stopCluster(cl)
res <- do.call(c, resultList)
View(resultList)
